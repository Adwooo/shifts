<%
rowcount = 1
@location_rows = {}
for location in @loc_groups.map{|lg| lg.locations }.flatten.uniq
  shifts = Shift.on_day(day).in_location(location).scheduled.sort_by{|s| s.start }
  rejected = []
  @location_rows[location] = []
  @location_rows[location][0] = []
  location_row = 0
  until shifts.empty?
    shift = shifts.shift #get first shift. shift... haha. (array.shift is a function)
    @location_rows[location][location_row] = [shift]
    (0...shifts.length).each do
      if shift.end > shifts.first.start
        rejected << shifts.shift
      else
        shift = shifts.shift
        @location_rows[location][location_row] << shift
      end
    end
    location_row += 1
    shifts = rejected
  end
  if location_row > 0
    rowcount += location_row
  else
    rowcount += 1
  end
end

@table_height = rowcount + @loc_groups.length * 0.25
@table_pixels = 26 * rowcount + rowcount*2
%>


<h2><a name="<%= day.to_s %>"><%= day.to_s(:just_date_long) %></a></h2>

<div class="timeline" style="height:<%= @table_pixels %>px; width: 100%;">
  <div class="days">
    <div class="day" style="height: <%= @table_pixels / (@table_height)%>px;"></div>
    <%= render :partial => "shifts/schedule/loc_group", :collection => @loc_groups %>
  </div>
  <div class="timeline-data">
    <ul class="intervals" style="height: <%= 100 / (@table_height)%>%;">
      <%= render :partial => "shifts/schedule/hour", :collection =>  @dept_start_hour...@dept_end_hour %>
    </ul>
    <%= render :partial => "shifts/schedule/loc_group_row", :collection => @loc_groups, :locals => {:day => day}  %>
  </div>
</div>
